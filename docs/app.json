[{"name":"app.R","content":"library(shiny)\nlibrary(leaflet)\nlibrary(xml2)\nlibrary(lubridate)\nlibrary(plotly)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# Define contrasting colors\nCONTRASTING_COLORS <- c(\"#FF0000\", \"#00FF00\", \"#0000FF\", \"#FF00FF\", \"#00FFFF\", \"#FFFF00\", \"#800000\", \"#008000\", \"#000080\", \"#800080\")\n\nconvert_tcx <- function(tcx_content) {\n  tcx <- read_xml(tcx_content)\n  ns <- c(ns = \"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2\")\n  \n  times <- as.POSIXct(xml_text(xml_find_all(tcx, \"//ns:Time\", ns = ns)), format = \"%Y-%m-%dT%H:%M:%OS\", tz = \"UTC\")\n  lats <- as.numeric(xml_text(xml_find_all(tcx, \"//ns:LatitudeDegrees\", ns = ns)))\n  lons <- as.numeric(xml_text(xml_find_all(tcx, \"//ns:LongitudeDegrees\", ns = ns)))\n  heart_rates <- as.numeric(xml_text(xml_find_all(tcx, \"//ns:HeartRateBpm/ns:Value\", ns = ns)))\n  \n  points <- data.frame(lat = lats, lon = lons)\n  start_time <- min(times)\n  duration <- as.numeric(difftime(max(times), min(times), units = \"secs\"))\n  \n  list(\n    points = points,\n    heart_rates = heart_rates,\n    start_time = start_time,\n    duration = duration,\n    timestamps = times\n  )\n}\n\nui <- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", href = \"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\"),\n    tags$script(src = \"https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\"),\n    tags$script(src = \"https://cdn.plot.ly/plotly-latest.min.js\")\n  ),\n  titlePanel(\"TCX Data Viewer\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"tcx_files\", \"Upload TCX file(s)\", accept = \".tcx\", multiple = TRUE),\n      uiOutput(\"file_info\")\n    ),\n    mainPanel(\n      div(\n        style = \"display: flex; flex-direction: column; gap: 10px;\",\n        leafletOutput(\"map\", height = \"400px\"),\n        uiOutput(\"heart_rate_plot_ui\")\n      ),\n      verbatimTextOutput(\"debug_info\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  tcx_data <- reactiveVal(list())\n  timeline_data <- reactiveVal(data.frame())\n  \n  observeEvent(input$tcx_files, {\n    req(input$tcx_files)\n    processed_data <- list()\n    all_data <- list()\n    \n    for (i in seq_along(input$tcx_files$datapath)) {\n      file <- input$tcx_files$datapath[i]\n      filename <- input$tcx_files$name[i]\n      \n      tryCatch({\n        tcx_content <- readLines(file, warn = FALSE)\n        tcx_content <- paste(tcx_content, collapse = \"\\n\")\n        result <- convert_tcx(tcx_content)\n        \n        color <- CONTRASTING_COLORS[(i - 1) %% length(CONTRASTING_COLORS) + 1]\n        processed_data[[filename]] <- c(\n          result,\n          list(\n            max_hr = max(result$heart_rates, na.rm = TRUE),\n            color = color\n          )\n        )\n        \n        df <- data.frame(\n          timestamp = result$timestamps,\n          heart_rate = result$heart_rates,\n          lat = result$points$lat,\n          lon = result$points$lon,\n          file = filename,\n          color = color\n        )\n        df$elapsed_time <- as.numeric(difftime(df$timestamp, min(df$timestamp), units = \"secs\")) / 60\n        all_data[[i]] <- df\n        \n        print(paste(\"Processed file:\", filename))\n        print(paste(\"Number of rows:\", nrow(df)))\n        print(paste(\"Columns:\", paste(colnames(df), collapse = \", \")))\n      }, error = function(e) {\n        processed_data[[filename]] <- list(error = paste(\"Error processing TCX data:\", e$message))\n        print(paste(\"Error processing file:\", filename, \"-\", e$message))\n      })\n    }\n    \n    tcx_data(processed_data)\n    \n    if (length(all_data) > 0) {\n      combined_data <- do.call(rbind, all_data)\n      timeline_data(combined_data)\n      print(\"Combined data:\")\n      print(paste(\"Total rows:\", nrow(combined_data)))\n      print(paste(\"Columns:\", paste(colnames(combined_data), collapse = \", \")))\n    } else {\n      print(\"No data processed successfully\")\n    }\n  })\n  \n  output$file_info <- renderUI({\n    data <- tcx_data()\n    if (length(data) == 0) {\n      return(p(\"Please upload TCX file(s).\"))\n    }\n    \n    info_html <- \"<h3>Run Data:<\/h3>\"\n    for (filename in names(data)) {\n      file_data <- data[[filename]]\n      if (\"error\" %in% names(file_data)) {\n        info_html <- paste0(info_html, sprintf(\"<p><strong>%s:<\/strong> Error: %s<\/p>\", filename, file_data$error))\n      } else {\n        duration_formatted <- sprintf(\"%02d:%02d:%02d\", \n                                      file_data$duration %/% 3600, \n                                      (file_data$duration %% 3600) %/% 60, \n                                      file_data$duration %% 60)\n        \n        info_html <- paste0(info_html, sprintf(\n          \"<p><strong>%s:<\/strong><br>Date: %s<br>Duration: %s<br>Max Heart Rate: %d bpm<\/p>\",\n          filename,\n          format(file_data$start_time, \"%Y-%m-%d\"),\n          duration_formatted,\n          file_data$max_hr\n        ))\n      }\n    }\n    \n    HTML(info_html)\n  })\n  \n  output$map <- renderLeaflet({\n    data <- tcx_data()\n    if (length(data) == 0) {\n      return(NULL)\n    }\n    \n    all_points <- do.call(rbind, lapply(data, function(x) x$points))\n    \n    m <- leaflet() %>%\n      addTiles() %>%\n      fitBounds(\n        lng1 = min(all_points$lon, na.rm = TRUE),\n        lat1 = min(all_points$lat, na.rm = TRUE),\n        lng2 = max(all_points$lon, na.rm = TRUE),\n        lat2 = max(all_points$lat, na.rm = TRUE)\n      )\n    \n    for (filename in names(data)) {\n      file_data <- data[[filename]]\n      if (!\"error\" %in% names(file_data)) {\n        m <- m %>%\n          addPolylines(\n            lat = file_data$points$lat,\n            lng = file_data$points$lon,\n            color = file_data$color,\n            weight = 2.5,\n            opacity = 0.8,\n            popup = filename\n          ) %>%\n          addCircleMarkers(\n            lat = file_data$points$lat[1],\n            lng = file_data$points$lon[1],\n            radius = 6,\n            color = \"green\",\n            fillOpacity = 1,\n            popup = paste(\"Start -\", filename)\n          ) %>%\n          addCircleMarkers(\n            lat = file_data$points$lat[nrow(file_data$points)],\n            lng = file_data$points$lon[nrow(file_data$points)],\n            radius = 6,\n            color = \"red\",\n            fillOpacity = 1,\n            popup = paste(\"End -\", filename)\n          )\n      }\n    }\n    \n    m\n  })\n  \n  output$heart_rate_plot_ui <- renderUI({\n    if (nrow(timeline_data()) > 0) {\n      plotlyOutput(\"heart_rate_plot\", height = \"300px\")\n    }\n  })\n  \n  output$heart_rate_plot <- renderPlotly({\n    data_info <- timeline_data()\n    req(nrow(data_info) > 0)\n    \n    print(\"Rendering heart rate plot\")\n    print(paste(\"Number of rows in data_info:\", nrow(data_info)))\n    print(paste(\"Columns in data_info:\", paste(colnames(data_info), collapse = \", \")))\n    \n    plot_data <- plot_ly()\n    \n    for (file_name in unique(data_info$file)) {\n      file_data <- data_info %>% \n        filter(file == file_name) %>% \n        drop_na(heart_rate, elapsed_time)\n      \n      print(paste(\"Processing file:\", file_name))\n      print(paste(\"Rows for this file:\", nrow(file_data)))\n      \n      if (nrow(file_data) > 0) {\n        plot_data <- plot_data %>% add_trace(\n          x = ~elapsed_time,\n          y = ~heart_rate,\n          type = 'scatter',\n          mode = 'lines',\n          name = file_name,\n          line = list(color = file_data$color[1]),\n          hoverinfo = 'text',\n          text = ~sprintf(\"File: %s<br>Time: %.2f min<br>Heart Rate: %d bpm\", file, elapsed_time, heart_rate),\n          data = file_data\n        )\n      } else {\n        print(paste(\"No valid data for file:\", file_name))\n      }\n    }\n    \n    max_time <- max(data_info$elapsed_time, na.rm = TRUE)\n    min_hr <- min(data_info$heart_rate, na.rm = TRUE)\n    max_hr <- max(data_info$heart_rate, na.rm = TRUE)\n    \n    print(paste(\"Max time:\", max_time))\n    print(paste(\"Heart rate range:\", min_hr, \"-\", max_hr))\n    \n    plot_data %>% \n  layout(\n    title = \"Heart Rate Over Time\",\n    xaxis = list(\n      title = \"Time Elapsed (minutes)\",\n      range = c(0, max_time)\n    ),\n    yaxis = list(\n      title = \"Heart Rate (bpm)\",\n      range = c(min_hr * 0.9, max_hr * 1.1)\n    ),\n    hovermode = \"closest\",\n    legend = list(orientation = \"h\", y = 1.02, yanchor = \"bottom\", x = 1, xanchor = \"right\")\n  ) %>%\n  event_register(\"plotly_hover\") %>%\n  config(displayModeBar = FALSE)  # This line disables the mode bar, which can sometimes interfere with events\n  })\n  \n  observeEvent(event_data(\"plotly_hover\"), {\n    hover_data <- event_data(\"plotly_hover\")\n    print(\"Hover event triggered\")\n    print(str(hover_data))  # Print the structure of hover_data for debugging\n    \n    if (!is.null(hover_data) && !is.null(hover_data$x)) {\n      print(\"Hover event detected\")\n      print(paste(\"Hover time:\", hover_data$x))\n      \n      hover_time <- hover_data$x\n      data_info <- timeline_data()\n      \n      if (nrow(data_info) > 0) {\n        tryCatch({\n          current_data <- data_info %>%\n            group_by(file) %>%\n            filter(abs(elapsed_time - hover_time) == min(abs(elapsed_time - hover_time))) %>%\n            slice(1) %>%\n            ungroup()\n          \n          print(\"Current data for map update:\")\n          print(current_data)\n          \n          if (nrow(current_data) > 0) {\n            leafletProxy(\"map\") %>%\n              clearMarkers() %>%\n              addCircleMarkers(\n                data = current_data,\n                lat = ~lat,\n                lng = ~lon,\n                radius = 8,\n                color = ~color,\n                fillColor = ~color,\n                fillOpacity = 0.8,\n                popup = ~sprintf(\"File: %s<br>Heart Rate: %d bpm<br>Time: %.2f min\", file, heart_rate, elapsed_time)\n              )\n          } else {\n            print(\"No data found for map update\")\n          }\n        }, error = function(e) {\n          print(paste(\"Error updating map:\", e$message))\n        })\n      } else {\n        print(\"No data available for map update\")\n      }\n    } else {\n      print(\"Hover event data is null or incomplete\")\n    }\n  })\n  \n  output$debug_info <- renderPrint({\n    data_info <- timeline_data()\n    if (nrow(data_info) == 0) {\n      return(\"No data available for debugging\")\n    }\n    \n    cat(\"Total rows:\", nrow(data_info), \"\\n\")\n    cat(\"Columns:\", paste(colnames(data_info), collapse = \", \"), \"\\n\")\n    cat(\"Heart rate range:\", min(data_info$heart_rate, na.rm = TRUE), \"-\", max(data_info$heart_rate, na.rm = TRUE), \"bpm\\n\")\n    cat(\"Time range:\", min(data_info$elapsed_time, na.rm = TRUE), \"-\", max(data_info$elapsed_time, na.rm = TRUE), \"minutes\\n\")\n    \n    cat(\"\\nSample data (first 5 rows):\\n\")\n    print(head(data_info, 5))\n  })\n}\n\nshinyApp(ui = ui, server = server)","type":"text"},{"name":"README.md","content":"# TCX Data Viewer\n\n## Overview\n\nTCX Data Viewer is a Shiny application that allows users to upload and visualize data from Training Center XML (TCX) files. This app is particularly useful for athletes and fitness enthusiasts who want to analyze their workout data, including GPS tracks and heart rate information.\n\n## Features\n\n1. **File Upload**: Users can upload one or multiple TCX files.\n2. **Interactive Map**: Displays GPS tracks of the uploaded activities on a Leaflet map.\n3. **Heart Rate Visualization**: Shows a plot of heart rate over time for all uploaded activities.\n4. **Activity Summary**: Provides key information about each uploaded file, including:\n   - Start date and time\n   - Duration\n   - Maximum heart rate\n\n## How to Use\n\n1. Launch the application.\n2. Use the file input in the sidebar to upload one or more TCX files.\n3. The app will process the files and display:\n   - A summary of each file's information in the sidebar\n   - GPS tracks on the map in the main panel\n   - A heart rate plot for all activities in the main panel\n\n## Technical Details\n\nThis application is built using R and the following key libraries:\n- shiny: For creating the web application\n- leaflet: For rendering interactive maps\n- xml2: For parsing TCX files\n- lubridate: For handling date-time data\n- ggplot2: For creating the heart rate plot\n\nThe app uses a color-coding system to distinguish between multiple uploaded files on both the map and the heart rate plot.\n\n## Installation\n\nTo run this application locally:\n\n1. Make sure you have R installed on your system.\n2. Install the required packages:\n   ```R\n   install.packages(c(\"shiny\", \"leaflet\", \"xml2\", \"lubridate\", \"ggplot2\"))\n3. Save the provided R script as app.R.\n\nRun the application in R:\n\nshiny::runApp(\"path/to/app.R\")\nNotes\nThe application supports multiple file uploads, allowing for comparison between different activities.\nError handling is implemented to manage issues with file processing.\nThe map shows start and end points for each activity, along with the full GPS track.\nThe heart rate plot allows for easy comparison of heart rate data across multiple activities.\n\nOr, you could just go [here](https://sayersr.github.io/2024_scgis_tcx_webr/) for the Shinylive version.","type":"text"},{"name":"_extensions/quarto-ext/shinylive/README.md","content":"# Shinylive package methods\n\n## Methods\n\n### R\n\nInteraction:\n\n```\nRscript -e 'shinylive:::quarto_ext()' [methods] [args]\n```\n\n### Python\n\nInteraction:\n\n```\nshinylive [methods] [args]\n```\n\n## CLI Methods\n\n* `extension info`\n  * Package, version, asset version, and script paths information\n* `extension base-htmldeps`\n  * Quarto html dependencies for the base shinylive integration\n* `extension language-resources`\n  * Language specific resource files for the quarto html dependency named `shinylive`\n* `extension app-resources`\n  * App specific resource files for the quarto html dependency named `shinylive`\n\n### CLI Interface\n* `extension info`\n  * Prints information about the extension including:\n    * `version`: The version of the R package\n    * `assets_version`: The version of the web assets\n    * `scripts`: A list of paths scripts that are used by the extension,\n     mainly `codeblock-to-json`\n  * Example\n    ```\n    {\n      \"version\": \"0.1.0\",\n      \"assets_version\": \"0.2.0\",\n      \"scripts\": {\n        \"codeblock-to-json\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/scripts/codeblock-to-json.js\"\n      }\n    }\n    ```\n* `extension base-htmldeps`\n  * Prints the language agnostic quarto html dependencies as a JSON array.\n    * The first html dependency is the `shinylive` service workers.\n    * The second html dependency is the `shinylive` base dependencies. This\n      dependency will contain the core `shinylive` asset scripts (JS files\n      automatically sourced), stylesheets (CSS files that are automatically\n      included), and resources (additional files that the JS and CSS files can\n      source).\n  * Example\n    ```\n    [\n      {\n        \"name\": \"shinylive-serviceworker\",\n        \"version\": \"0.2.0\",\n        \"meta\": { \"shinylive:serviceworker_dir\": \".\" },\n        \"serviceworkers\": [\n          {\n            \"source\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive-sw.js\",\n            \"destination\": \"/shinylive-sw.js\"\n          }\n        ]\n      },\n      {\n        \"name\": \"shinylive\",\n        \"version\": \"0.2.0\",\n        \"scripts\": [{\n          \"name\": \"shinylive/load-shinylive-sw.js\",\n          \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/load-shinylive-sw.js\",\n            \"attribs\": { \"type\": \"module\" }\n        }],\n        \"stylesheets\": [{\n          \"name\": \"shinylive/shinylive.css\",\n          \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/shinylive.css\"\n        }],\n        \"resources\": [\n          {\n            \"name\": \"shinylive/shinylive.js\",\n            \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/shinylive.js\"\n          },\n          ... # [ truncated ]\n        ]\n      }\n    ]\n    ```\n* `extension language-resources`\n  * Prints the language-specific resource files as JSON that should be added to the quarto html dependency.\n    * For r-shinylive, this includes the webr resource files\n    * For py-shinylive, this includes the pyodide and pyright resource files.\n  * Example\n    ```\n    [\n      {\n        \"name\": \"shinylive/webr/esbuild.d.ts\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/webr/esbuild.d.ts\"\n      },\n      {\n        \"name\": \"shinylive/webr/libRblas.so\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/webr/libRblas.so\"\n      },\n      ... # [ truncated ]\n    ]\n* `extension app-resources`\n  * Prints app-specific resource files as JSON that should be added to the `\"shinylive\"` quarto html dependency.\n  * Currently, r-shinylive does not return any resource files.\n  * Example\n    ```\n    [\n      {\n        \"name\": \"shinylive/pyodide/anyio-3.7.0-py3-none-any.whl\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/pyodide/anyio-3.7.0-py3-none-any.whl\"\n      },\n      {\n        \"name\": \"shinylive/pyodide/appdirs-1.4.4-py2.py3-none-any.whl\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/pyodide/appdirs-1.4.4-py2.py3-none-any.whl\"\n      },\n      ... # [ truncated ]\n    ]\n    ```\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/_extension.yml","content":"name: shinylive\ntitle: Embedded Shinylive applications\nauthor: Winston Chang\nversion: 0.2.0\nquarto-required: \">= 1.2.198\"\ncontributes:\n  filters:\n    - shinylive.lua\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/resources/css/shinylive-quarto.css","content":"div.output-content,\ndiv.shinylive-wrapper {\n  background-color: rgba(250, 250, 250, 0.65);\n  border: 1px solid rgba(233, 236, 239, 0.65);\n  border-radius: 0.5rem;\n  box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.04), 0px 3px 7px rgba(0, 0, 0, 0.04),\n    0px 12px 30px rgba(0, 0, 0, 0.07);\n  margin-top: 32px;\n  margin-bottom: 32px;\n}\n\ndiv.shinylive-wrapper {\n  margin: 1em 0;\n  border-radius: 8px;\n}\n\n.shinylive-container {\n  background-color: #eeeff2;\n  min-height: auto;\n}\n\n.shinylive-container > div {\n  box-shadow: none;\n}\n\n.editor-container .cm-editor .cm-scroller {\n  font-size: 13px;\n  line-height: 1.5;\n}\n\niframe.app-frame {\n  /* Override the default margin from Bootstrap */\n  margin-bottom: 0;\n}\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/shinylive.lua","content":"-- Notes:\n-- * 2023/10/04 - Barret:\n--   Always use `callShinyLive()` to call a shinylive extension.\n--   `callPythonShinyLive()` and `callRShinyLive()` should not be used directly.\n--   Instead, always use `callShinyLive()`.\n-- * 2023/10/04 - Barret:\n--   I could not get `error(msg)` to quit the current function execution and\n--   bubble up the stack and stop. Instead, I am using `assert(false, msg)` to\n--   achieve the desired behavior. Multi-line error messages should start with a\n--   `\\n` to keep the message in the same readable area.\n\n\n-- `table` to organize flags to have code only run once.\nlocal hasDoneSetup = { base = false, r = false, python = false, python_version = false }\n-- `table` to store `{ version, assets_version }` for each language's extension.\n-- If both `r` and `python` are used in the same document, then the\n-- `assets_version` for each language must be the same.\nlocal versions = { r = nil, python = nil }\n-- Global variable for the codeblock-to-json.js script file location\nlocal codeblockScript = nil\n-- Global hash table to store app specific dependencies to avoid calling\n-- `quarto.doc.attach_to_dependency()` multiple times for the same dependency.\nlocal appSpecificDeps = {}\n\n-- Display error message and throw error w/ short message\n-- @param msg: string Error message to be displayed\n-- @param short_msg: string Error message to be thrown\nfunction throw_quarto_error(err_msg, ...)\n  n = select(\"#\", ...)\n  if n > 0 then\n    -- Display any meta information about the error\n    -- Add blank lines after msg for line separation for better readability\n    quarto.log.error(...)\n  else\n    quarto.log.error(err_msg .. \"\\n\\n\")\n  end\n  -- Add blank lines after short_msg for line separation for better readability\n  -- Use assert(false, msg) to quit the current function execution and\n  -- bubble up the stack and stop. Barret: I could not get this to work with `error(msg)`.\n  assert(false, err_msg .. \"\\n\")\nend\n\n-- Python specific method to call py-shinylive\n-- @param args: list of string arguments to pass to py-shinylive\n-- @param input: string to pipe into to py-shinylive\nfunction callPythonShinylive(args, input)\n  -- Try calling `pandoc.pipe('shinylive', ...)` and if it fails, print a message\n  -- about installing shinylive python package.\n  local res\n  local status, err = pcall(\n    function()\n      res = pandoc.pipe(\"shinylive\", args, input)\n    end\n  )\n\n  if not status then\n    throw_quarto_error(\n      \"Error running 'shinylive' command. Perhaps you need to install / update the 'shinylive' Python package?\",\n      \"Error running 'shinylive' command. Perhaps you need to install / update the 'shinylive' Python package?\\n\",\n      \"Error:\\n\",\n      err\n    )\n  end\n\n  return res\nend\n\n-- R specific method to call {r-shinylive}\n-- @param args: list of string arguments to pass to r-shinylive\n-- @param input: string to pipe into to r-shinylive\nfunction callRShinylive(args, input)\n  args = { \"-e\",\n    \"shinylive:::quarto_ext()\",\n    table.unpack(args) }\n\n  -- Try calling `pandoc.pipe('Rscript', ...)` and if it fails, print a message\n  -- about installing shinylive R package.\n  local res\n  local status, err = pcall(\n    function()\n      res = pandoc.pipe(\"Rscript\", args, input)\n    end\n  )\n\n  if not status then\n    throw_quarto_error(\n      \"Error running 'Rscript' command. Perhaps you need to install / update the 'shinylive' R package?\",\n      \"Error running 'Rscript' command. Perhaps you need to install / update the 'shinylive' R package?\\n\",\n      \"Error:\\n\",\n      err\n    )\n  end\n\n  return res\nend\n\n-- Returns decoded object\n-- @param language: \"python\" or \"r\"\n-- @param args, input: see `callPythonShinylive` and `callRShinylive`\nfunction callShinylive(language, args, input, parseJson)\n  if input == nil then\n    input = \"\"\n  end\n  if parseJson == nil then\n    parseJson = true\n  end\n\n  local res\n  -- print(\"Calling \" .. language .. \" shinylive with args: \", args)\n  if language == \"python\" then\n    res = callPythonShinylive(args, input)\n  elseif language == \"r\" then\n    res = callRShinylive(args, input)\n  else\n    throw_quarto_error(\"internal - Unknown language: \" .. language)\n  end\n\n  if not parseJson then\n    return res\n  end\n\n  -- Remove any unwanted output before the first curly brace or square bracket.\n  -- print(\"res: \" .. string.sub(res, 1, math.min(string.len(res), 100)) .. \"...\")\n  local curly_start = string.find(res, \"{\", 0, true)\n  local brace_start = string.find(res, \"[\", 0, true)\n  local min_start\n  if curly_start == nil then\n    min_start = brace_start\n  elseif brace_start == nil then\n    min_start = curly_start\n  else\n    min_start = math.min(curly_start, brace_start)\n  end\n  if min_start == nil then\n    local res_str = res\n    if string.len(res) > 100 then\n      res_str = string.sub(res, 1, 100) .. \"... [truncated]\"\n    end\n    throw_quarto_error(\n      \"Could not find start curly brace or start brace in \" ..\n      language .. \" shinylive response. Is JSON being returned from the \" .. language .. \" `shinylive` package?\",\n      \"Could not find start curly brace or start brace in \" .. language .. \" shinylive response.\\n\",\n      \"JSON string being parsed:\\n\",\n      res_str\n    )\n  end\n  if min_start > 1 then\n    res = string.sub(res, min_start)\n  end\n\n\n  -- Decode JSON object\n  local result\n  local status, err = pcall(\n    function()\n      result = quarto.json.decode(res)\n    end\n  )\n  if not status then\n    throw_quarto_error(\n      \"Error decoding JSON response from `shinylive` \" .. language .. \" package.\",\n      \"Error decoding JSON response from `shinylive` \" .. language .. \" package.\\n\",\n      \"JSON string being parsed:\\n\",\n      res,\n      \"Error:\\n\",\n      err\n    )\n  end\n  return result\nend\n\nfunction parseVersion(versionTxt)\n  local versionParts = {}\n  for part in string.gmatch(versionTxt, \"%d+\") do\n    table.insert(versionParts, tonumber(part))\n  end\n  local ret = {\n    major = nil,\n    minor = nil,\n    patch = nil,\n    extra = nil,\n    length = #versionParts,\n    str = versionTxt\n  }\n\n  if ret.length >= 1 then\n    ret.major = versionParts[1]\n    if ret.length >= 2 then\n      ret.minor = versionParts[2]\n      if ret.length >= 3 then\n        ret.patch = versionParts[3]\n        if ret.length >= 4 then\n          ret.extra = versionParts[4]\n        end\n      end\n    end\n  end\n\n  return ret\nend\n\n-- If verA > verB, return 1\n-- If verA == verB, return 0\n-- If verA < verB, return -1\nfunction compareVersions(verA, verB)\n  if verA.major == nil or verB.major == nil then\n    throw_quarto_error(\"Trying to compare an invalid version: \" .. verA.str .. \" or \" .. verB.str)\n  end\n\n  for index, key in ipairs({ \"major\", \"minor\", \"patch\", \"extra\" }) do\n    local partDiff = compareVersionPart(verA[key], verB[key])\n    if partDiff ~= 0 then\n      return partDiff\n    end\n  end\n\n  -- Equal!\n  return 0\nend\n\nfunction compareVersionPart(aPart, bPart)\n  if aPart == nil and bPart == nil then\n    return 0\n  end\n  if aPart == nil then\n    return -1\n  end\n  if bPart == nil then\n    return 1\n  end\n  if aPart > bPart then\n    return 1\n  elseif aPart < bPart then\n    return -1\n  end\n\n  -- Equal!\n  return 0\nend\n\nfunction ensurePyshinyliveVersion(language)\n  -- Quit early if not python\n  if language ~= \"python\" then\n    return\n  end\n  -- Quit early if already completed check\n  if hasDoneSetup.python_version then\n    return\n  end\n  hasDoneSetup.python_version = true\n\n  -- Verify that min python shinylive version is met\n  pyShinyliveVersion = callShinylive(language, { \"--version\" }, \"\", false)\n  -- Remove trailing whitespace\n  pyShinyliveVersion = pyShinyliveVersion:gsub(\"%s+$\", \"\")\n  -- Parse version into table\n  parsedVersion = parseVersion(pyShinyliveVersion)\n\n  -- Verify that the version is at least 0.1.0\n  if\n      (parsedVersion.length < 3) or\n      -- Major and minor values are 0. Ex: 0.0.18\n      (parsedVersion.major == 0 and parsedVersion.minor == 0)\n  then\n    assert(false,\n      \"\\nThe shinylive Python package must be at least version v0.1.0 to be used in a Quarto document.\" ..\n      \"\\n\\nInstalled Python Shinylive package version: \" .. pyShinyliveVersion ..\n      \"\\n\\nPlease upgrade the Python Shinylive package by running:\" ..\n      \"\\n\\tpip install --upgrade shinylive\" ..\n      \"\\n\\n(If you are using a virtual environment, please activate it before running the command above.)\"\n    )\n  end\nend\n\n-- Do one-time setup for language agnostic html dependencies.\n-- This should only be called once per document\n-- @param language: \"python\" or \"r\"\nfunction ensureBaseSetup(language)\n  -- Quit early if already done\n  if hasDoneSetup.base then\n    return\n  end\n  hasDoneSetup.base = true\n\n  -- Find the path to codeblock-to-json.ts and save it for later use.\n  local infoObj = callShinylive(language, { \"extension\", \"info\" })\n  -- Store the path to codeblock-to-json.ts for later use\n  codeblockScript = infoObj.scripts['codeblock-to-json']\n  -- Store the version info for later use\n  versions[language] = { version = infoObj.version, assets_version = infoObj.assets_version }\n\n  -- Add language-agnostic dependencies\n  local baseDeps = getShinyliveBaseDeps(language)\n  for idx, dep in ipairs(baseDeps) do\n    quarto.doc.add_html_dependency(dep)\n  end\n\n  -- Add ext css dependency\n  quarto.doc.add_html_dependency(\n    {\n      name = \"shinylive-quarto-css\",\n      stylesheets = { \"resources/css/shinylive-quarto.css\" }\n    }\n  )\nend\n\n-- Do one-time setup for language specific html dependencies.\n-- This should only be called once per document\n-- @param language: \"python\" or \"r\"\nfunction ensureLanguageSetup(language)\n  -- Min version check must be done first\n  ensurePyshinyliveVersion(language)\n\n  -- Make sure the base setup is done before the langage setup\n  ensureBaseSetup(language)\n\n  if hasDoneSetup[language] then\n    return\n  end\n  hasDoneSetup[language] = true\n\n  -- Only get the asset version value if it hasn't been retrieved yet.\n  if versions[language] == nil then\n    local infoObj = callShinylive(language, { \"extension\", \"info\" })\n    versions[language] = { version = infoObj.version, assets_version = infoObj.assets_version }\n  end\n  -- Verify that the r-shinylive and py-shinylive supported assets versions match\n  if\n      (versions.r and versions.python) and\n      ---@diagnostic disable-next-line: undefined-field\n      versions.r.assets_version ~= versions.python.assets_version\n  then\n    local parsedRAssetsVersion = parseVersion(versions.r.assets_version)\n    local parsedPythonAssetsVersion = parseVersion(versions.python.assets_version)\n\n    local verDiff = compareVersions(parsedRAssetsVersion, parsedPythonAssetsVersion)\n    local verDiffStr = \"\"\n    if verDiff == 1 then\n      -- R shinylive supports higher version of assets. Upgrade python shinylive\n      verDiffStr =\n          \"The currently installed python shinylive package supports a lower assets version, \" ..\n          \"therefore we recommend updating your python shinylive package to the latest version.\"\n    elseif verDiff == -1 then\n      -- Python shinylive supports higher version of assets. Upgrade R shinylive\n      verDiffStr =\n          \"The currently installed R shinylive package supports a lower assets version, \" ..\n          \"therefore we recommend updating your R shinylive package to the latest version.\"\n    end\n\n    throw_quarto_error(\n      \"The shinylive R and Python packages must support the same Shinylive Assets version to be used in the same Quarto document.\",\n      \"The shinylive R and Python packages must support the same Shinylive Assets version to be used in the same Quarto document.\\n\",\n      \"\\n\",\n      \"Python shinylive package version: \",\n      ---@diagnostic disable-next-line: undefined-field\n      versions.python.version .. \" ; Supported assets version: \" .. versions.python.assets_version .. \"\\n\",\n      \"R shinylive package version:       \" ..\n      ---@diagnostic disable-next-line: undefined-field\n      versions.r.version .. \" ; Supported assets version: \" .. versions.r.assets_version .. \"\\n\",\n      \"\\n\",\n      verDiffStr .. \"\\n\",\n      \"\\n\",\n      \"To update your R Shinylive package, run:\\n\",\n      \"\\tR -e \\\"install.packages('shinylive')\\\"\\n\",\n      \"\\n\",\n      \"To update your Python Shinylive package, run:\\n\",\n      \"\\tpip install --upgrade shinylive\\n\",\n      \"(If you are using a virtual environment, please activate it before running the command above.)\\n\",\n      \"\\n\"\n    )\n  end\n\n  -- Add language-specific dependencies\n  local langResources = callShinylive(language, { \"extension\", \"language-resources\" })\n  for idx, resourceDep in ipairs(langResources) do\n    -- No need to check for uniqueness.\n    -- Each resource is only be added once and should already be unique.\n    quarto.doc.attach_to_dependency(\"shinylive\", resourceDep)\n  end\nend\n\nfunction getShinyliveBaseDeps(language)\n  -- Relative path from the current page to the root of the site. This is needed\n  -- to find out where shinylive-sw.js is, relative to the current page.\n  if quarto.project.offset == nil then\n    throw_quarto_error(\"The `shinylive` extension must be used in a Quarto project directory (with a _quarto.yml file).\")\n  end\n  local deps = callShinylive(\n    language,\n    { \"extension\", \"base-htmldeps\", \"--sw-dir\", quarto.project.offset },\n    \"\"\n  )\n  return deps\nend\n\n-- Legacy quarto cli location\nquarto_cli_path = \"quarto\"\nif quarto.config ~= nil and quarto.config.cli_path ~= nil then\n  -- * 2024/05/03 - Christophe:\n  --   `quarto run` needs to be called using the same quarto CLI that called the extension.\n  --   This is done by using `quarto.config.cli_path()` from Quarto 1.5 Lua API.\n  --   https://github.com/quarto-dev/quarto-cli/pull/9576\n  quarto_cli_path = quarto.config.cli_path()\nend\n\nreturn {\n  {\n    CodeBlock = function(el)\n      if not el.attr then\n        -- Not a shinylive codeblock, return\n        return\n      end\n\n      local language\n      if el.attr.classes:includes(\"{shinylive-r}\") then\n        language = \"r\"\n      elseif el.attr.classes:includes(\"{shinylive-python}\") then\n        language = \"python\"\n      else\n        -- Not a shinylive codeblock, return\n        return\n      end\n      -- Setup language and language-agnostic dependencies\n      ensureLanguageSetup(language)\n\n      -- Convert code block to JSON string in the same format as app.json.\n      local parsedCodeblockJson = pandoc.pipe(\n        quarto_cli_path,\n        { \"run\", codeblockScript, language },\n        el.text\n      )\n\n      -- This contains \"files\" and \"quartoArgs\" keys.\n      local parsedCodeblock = quarto.json.decode(parsedCodeblockJson)\n\n      -- Find Python package dependencies for the current app.\n      local appDeps = callShinylive(\n        language,\n        { \"extension\", \"app-resources\" },\n        -- Send as piped input to the shinylive command\n        quarto.json.encode(parsedCodeblock[\"files\"])\n      )\n\n      -- Add app specific dependencies\n      for idx, dep in ipairs(appDeps) do\n        if not appSpecificDeps[dep.name] then\n          appSpecificDeps[dep.name] = true\n          quarto.doc.attach_to_dependency(\"shinylive\", dep)\n        end\n      end\n\n      if el.attr.classes:includes(\"{shinylive-python}\") then\n        el.attributes.engine = \"python\"\n        el.attr.classes = pandoc.List()\n        el.attr.classes:insert(\"shinylive-python\")\n      elseif el.attr.classes:includes(\"{shinylive-r}\") then\n        el.attributes.engine = \"r\"\n        el.attr.classes = pandoc.List()\n        el.attr.classes:insert(\"shinylive-r\")\n      end\n      return el\n    end\n  }\n}\n","type":"text"},{"name":"requirements.txt","content":"shiny\nleaflet\nxml2\nlubridate\nggplot2\n","type":"text"}]
